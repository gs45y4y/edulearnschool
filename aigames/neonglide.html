<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Neon Glide: Hardcore Mode</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #050510;
			font-family: 'Courier New', Courier, monospace;
			touch-action: none;
		}

		canvas {
			display: block;
		}

		/* UI Overlay */
		#ui-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			display: flex;
			flex-direction: column;
			padding: 20px;
		}

		.score-board {
			color: #fff;
			text-shadow: 0 0 10px #00f3ff;
			font-size: 24px;
			font-weight: bold;
			z-index: 10;
		}

		.high-score {
			font-size: 14px;
			color: #aaa;
		}

		/* Level Up Flash */
		#level-indicator {
			position: absolute;
			top: 20%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 40px;
			font-weight: 900;
			color: #ff0055;
			text-shadow: 0 0 20px #ff0055;
			opacity: 0;
			transition: opacity 0.2s;
			text-transform: uppercase;
			letter-spacing: 5px;
			pointer-events: none;
		}

		/* Menu */
		#menu {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			text-align: center;
			background: rgba(0, 0, 0, 0.9);
			padding: 40px;
			border: 2px solid #00f3ff;
			border-radius: 10px;
			box-shadow: 0 0 40px rgba(0, 243, 255, 0.2);
			pointer-events: auto;
			display: flex;
			flex-direction: column;
			gap: 15px;
			z-index: 20;
		}

		h1 {
			color: #fff;
			margin: 0;
			text-transform: uppercase;
			letter-spacing: 4px;
			text-shadow: 3px 3px 0px #bc13fe;
		}

		button {
			background: transparent;
			color: #00f3ff;
			border: 2px solid #00f3ff;
			padding: 15px 30px;
			font-size: 18px;
			font-family: inherit;
			font-weight: bold;
			cursor: pointer;
			transition: 0.2s;
			text-transform: uppercase;
		}

		button:hover {
			background: #00f3ff;
			color: #000;
			box-shadow: 0 0 20px #00f3ff;
		}

		.hidden {
			display: none !important;
		}

		.controls-hint {
			position: absolute;
			bottom: 20px;
			width: 100%;
			text-align: center;
			color: rgba(255, 255, 255, 0.4);
			font-size: 12px;
			pointer-events: none;
		}
	</style>
</head>

<body>

	<div id="ui-layer">
		<div class="score-board">
			SCORE: <span id="score">0</span>
			<div class="high-score">BEST: <span id="best-score">0</span></div>
			<div style="font-size: 14px; color: #ff0055; margin-top: 5px;">SPEED: <span id="speed-display">100%</span>
			</div>
		</div>
		<div id="level-indicator">SPEED UP!</div>
	</div>

	<div id="menu">
		<h1>Neon Glide</h1>
		<p id="final-score-display" class="hidden" style="color: #ccc;">SCORE: 0</p>
		<button id="start-btn">START GAME</button>
	</div>

	<div class="controls-hint">MOUSE or ARROWS to move | P to Pause</div>
	<canvas id="gameCanvas"></canvas>

	<script>
		const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('start-btn');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('best-score');
    const speedEl = document.getElementById('speed-display');
    const finalScoreDisplay = document.getElementById('final-score-display');
    const levelIndicator = document.getElementById('level-indicator');

    // Game State
    let isPlaying = false;
    let isPaused = false;
    let score = 0;
    let highScore = localStorage.getItem('neonGlideHighScore') || 0;
    
    // DIFFICULTY VARIABLES
    let baseSpeed = 7;
    let speed = baseSpeed;
    let frameCount = 0;

    // Dimensions
    let width, height;

    const COLORS = {
        bg: '#050510',
        player: '#00f3ff',
        obstacle: '#bc13fe',
        trail: 'rgba(0, 243, 255, 0.5)',
        grid: 'rgba(255, 255, 255, 0.05)'
    };

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    bestScoreEl.innerText = highScore;

    // Input
    const input = { x: 0, targetX: 0 };
    
    window.addEventListener('mousemove', (e) => {
        if (!isPlaying || isPaused) return;
        input.targetX = (e.clientX / width) * 2 - 1;
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === 'p' || e.key === 'P') togglePause();
        if (!isPlaying) return;
        if (e.key === 'ArrowLeft') input.targetX -= 0.15;
        if (e.key === 'ArrowRight') input.targetX += 0.15;
        input.targetX = Math.max(-1, Math.min(1, input.targetX));
    });

    // --- CLASSES ---

    class Player {
        constructor() {
            this.x = 0;
            this.y = height - 100;
            this.radius = 15;
            this.trail = [];
        }

        update() {
            // Movement physics (Slide)
            this.x += (input.targetX - this.x) * 0.15;
            
            // Wall bump
            if (this.x < -1) { this.x = -1; input.targetX = -1; }
            if (this.x > 1) { this.x = 1; input.targetX = 1; }

            // Trail Logic
            if (frameCount % 3 === 0) {
                this.trail.push({ x: this.getScreenX(), y: this.y, size: this.radius, alpha: 0.8 });
            }
            for (let i = this.trail.length - 1; i >= 0; i--) {
                this.trail[i].y += speed; 
                this.trail[i].size *= 0.9;
                this.trail[i].alpha -= 0.05;
                if (this.trail[i].alpha <= 0) this.trail.splice(i, 1);
            }
        }

        draw() {
            // Draw Trail
            for (let t of this.trail) {
                ctx.fillStyle = `rgba(0, 243, 255, ${t.alpha})`;
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
                ctx.fill();
            }
            // Draw Player
            const screenX = this.getScreenX();
            ctx.shadowBlur = 20;
            ctx.shadowColor = COLORS.player;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(screenX, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        getScreenX() { return (this.x + 1) * (width / 2); }
    }

    class Obstacle {
        constructor() {
            this.width = Math.random() * (width * 0.25) + 60;
            this.height = 40;
            this.y = -100;
            this.laneX = (Math.random() * 2 - 1); 
            this.active = true;
            this.color = Math.random() > 0.9 ? '#ff0055' : COLORS.obstacle;
        }

        update() {
            this.y += speed;
            if (this.y > height + 100) this.active = false;
        }

        draw() {
            const screenX = (this.laneX + 1) * (width / 2) - (this.width / 2);
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            ctx.fillRect(screenX, this.y, this.width, this.height);
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillRect(screenX, this.y, this.width, 4);
        }

        checkCollision(player) {
            const px = player.getScreenX();
            const ox = (this.laneX + 1) * (width / 2) - (this.width / 2);
            
            // AABB vs Point/Circle Approx
            let testX = px;
            let testY = player.y;

            if (px < ox) testX = ox;
            else if (px > ox + this.width) testX = ox + this.width;

            if (player.y < this.y) testY = this.y;
            else if (player.y > this.y + this.height) testY = this.y + this.height;

            const dist = Math.sqrt(((px-testX)*(px-testX)) + ((player.y-testY)*(player.y-testY)));
            return dist <= player.radius - 2; // -2 for slight forgiveness
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 1;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.life -= 0.03;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- GAME LOGIC ---
    let player;
    let obstacles = [];
    let particles = [];
    let gridOffset = 0;

    function initGame() {
        player = new Player();
        obstacles = [];
        particles = [];
        score = 0;
        speed = baseSpeed; // Reset speed
        scoreEl.innerText = '0';
        speedEl.innerText = '100%';
        input.targetX = 0;
        isPlaying = true;
        isPaused = false;
        menu.classList.add('hidden');
        finalScoreDisplay.classList.add('hidden');
        loop();
    }

    function triggerLevelUp() {
        // VISUAL EFFECT
        levelIndicator.style.opacity = 1;
        levelIndicator.style.transform = "translate(-50%, -50%) scale(1.2)";
        setTimeout(() => {
            levelIndicator.style.opacity = 0;
            levelIndicator.style.transform = "translate(-50%, -50%) scale(1)";
        }, 800);

        // DIFFICULTY LOGIC
        speed += 0.8; // Increase speed
        
        // Update UI
        let speedPct = Math.round((speed / baseSpeed) * 100);
        speedEl.innerText = speedPct + "%";
    }

    function spawnObstacle() {
        // Spawn rate gets faster as score goes up
        // We calculate 'frames between spawns'
        let baseSpawnRate = 50; 
        
        // Reduce spawn delay based on score (cap at minimum 15 frames)
        let currentSpawnRate = Math.max(15, baseSpawnRate - Math.floor(score / 50));

        if (frameCount % currentSpawnRate === 0) {
            obstacles.push(new Obstacle());
        }
    }

    function gameOver() {
        isPlaying = false;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('neonGlideHighScore', highScore);
            bestScoreEl.innerText = highScore;
        }
        finalScoreDisplay.innerText = `SCORE: ${score}`;
        finalScoreDisplay.classList.remove('hidden');
        menu.classList.remove('hidden');
        startBtn.innerText = "RETRY";
    }

    function togglePause() {
        if (!isPlaying) return;
        isPaused = !isPaused;
        if (!isPaused) loop();
        else {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,width,height);
            ctx.fillStyle = '#fff';
            ctx.font = '30px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText("PAUSED", width/2, height/2);
        }
    }

    function loop() {
        if (!isPlaying || isPaused) return;

        // Clear
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // Draw Grid
        ctx.shadowBlur = 0;
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        gridOffset = (gridOffset + speed) % 50;
        // Horizontal Lines
        for(let i=0; i<height/50 + 1; i++) {
            let y = (i * 50) + gridOffset;
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
        }
        // Vertical Perspective Lines
        ctx.beginPath(); ctx.moveTo(width/2, height/2); ctx.lineTo(0, height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(width/2, height/2); ctx.lineTo(width, height); ctx.stroke();

        // Update Score & Difficulty
        frameCount++;
        if (frameCount % 10 === 0) {
            score++;
            scoreEl.innerText = score;

            // DIFFICULTY CHECK: Every 50 points
            if (score > 0 && score % 50 === 0) {
                triggerLevelUp();
            }
        }

        spawnObstacle();

        // Obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.update();
            obs.draw();

            if (obs.checkCollision(player)) {
                // Explosion
                for(let k=0; k<20; k++) particles.push(new Particle(player.getScreenX(), player.y, COLORS.player));
                particles.forEach(p => { p.update(); p.draw(); });
                
                gameOver();
                return;
            }
            if (!obs.active) obstacles.splice(i, 1);
        }

        // Player
        player.update();
        player.draw();

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        requestAnimationFrame(loop);
    }

    startBtn.addEventListener('click', initGame);

	</script>
</body>

</html>