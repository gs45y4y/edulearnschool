<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>PAC-MAN: ARCADE CORE</title>
	<style>
		body {
			background-color: #111;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			margin: 0;
			color: white;
			font-family: monospace;
			overflow: hidden;
			user-select: none;
		}

		#cabinet {
			position: relative;
			border: 8px solid #222;
			background: black;
			box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
		}

		#ui {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 40px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0 20px;
			font-size: 20px;
			font-weight: bold;
			z-index: 10;
			text-shadow: 2px 2px 0 #000;
		}

		canvas {
			display: block;
			background: #000;
		}

		#overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.85);
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 20;
		}

		#overlay h1 {
			color: red;
			font-size: 48px;
			margin-bottom: 20px;
			text-shadow: 0 0 10px red;
		}

		button {
			background: transparent;
			color: yellow;
			border: 4px solid yellow;
			padding: 15px 40px;
			font-size: 24px;
			font-weight: bold;
			font-family: inherit;
			cursor: pointer;
			text-transform: uppercase;
		}

		button:hover {
			background: yellow;
			color: black;
			box-shadow: 0 0 20px yellow;
		}
	</style>
</head>

<body>

	<div id="cabinet">
		<div id="ui">
			<span>SCORE: <span id="score">0</span></span>
			<span>LIVES: <span id="lives">3</span></span>
		</div>
		<canvas id="gameCanvas"></canvas>

		<div id="overlay">
			<h1 id="msg">INSERT COIN</h1>
			<button onclick="initGame()">START GAME</button>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONSTANTS ---
const TILE = 32;
const SPEED = 2; // Must be a factor of TILE (1, 2, 4, 8)
const GHOST_SPEED = 2; 

// 1=Wall, 0=Dot, 2=Empty, 3=Power, 4=Gate, 9=House
const MAP_DATA = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
    [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,4,1,1,1,0,1,1,0,1,0,1],
    [1,0,0,0,0,1,9,9,9,9,9,1,0,0,0,0,0,0,1],
    [1,1,1,1,0,1,9,9,9,9,9,1,0,1,1,1,1,1,1],
    [2,2,2,2,0,2,9,9,9,9,9,2,0,2,2,2,2,2,2],
    [1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
    [1,3,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,3,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const ROWS = MAP_DATA.length;
const COLS = MAP_DATA[0].length;
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;

// --- VARIABLES ---
let gameRunning = false;
let score = 0;
let lives = 3;
let powerTick = 0;

const UP = {x:0, y:-1};
const DOWN = {x:0, y:1};
const LEFT = {x:-1, y:0};
const RIGHT = {x:1, y:0};
const STOP = {x:0, y:0};

let pacman = { x:0, y:0, dir:STOP, nextDir:STOP };
let ghosts = [];
let dots = [];

// --- INITIALIZATION ---
function initGame() {
    score = 0; lives = 3;
    document.getElementById('overlay').style.display = 'none';
    
    // Parse dots
    dots = [];
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(MAP_DATA[r][c] === 0 || MAP_DATA[r][c] === 3) {
                dots.push({x:c, y:r, power: MAP_DATA[r][c]===3, active:true});
            }
        }
    }
    
    resetLevel();
    gameRunning = true;
    requestAnimationFrame(gameLoop);
}

function resetLevel() {
    pacman = { x: 9*TILE, y: 10*TILE, dir: LEFT, nextDir: LEFT };
    ghosts = [
        { x:9*TILE, y:4*TILE, color:'red', dir:LEFT, state:'CHASE' },
        { x:9*TILE, y:7*TILE, color:'pink', dir:UP, state:'EXITING' },
        { x:8*TILE, y:7*TILE, color:'cyan', dir:UP, state:'EXITING' },
        { x:10*TILE, y:7*TILE, color:'orange', dir:UP, state:'EXITING' }
    ];
    updateUI();
}

// --- CORE MOVEMENT ENGINE ---
function moveActor(actor, speed) {
    // 1. Calculate future position
    let nx = actor.x + actor.dir.x * speed;
    let ny = actor.y + actor.dir.y * speed;

    // 2. Wrap Around
    if (nx < -TILE) nx = canvas.width;
    if (nx > canvas.width) nx = -TILE;

    // 3. Center Detection
    // Are we crossing the center of a tile?
    let prevTile = getTile(actor.x, actor.y);
    let nextTile = getTile(nx, ny);
    
    // Aligning to grid
    let centerX = prevTile.x * TILE;
    let centerY = prevTile.y * TILE;
    
    // Distance to center before move
    let distBefore = Math.abs(actor.x - centerX) + Math.abs(actor.y - centerY);
    // Distance to center after move
    let distAfter = Math.abs(nx - centerX) + Math.abs(ny - centerY);

    // If we passed the center (distance got bigger or we changed tiles)
    // OR if we are exactly on center
    let atCenter = (distAfter >= distBefore && distBefore < speed);

    if (atCenter) {
        // SNAP to exact center
        actor.x = centerX;
        actor.y = centerY;
        
        // --- DECISION POINT ---
        if (actor === pacman) {
            // Try queued direction
            if (actor.nextDir !== STOP && !isWall(prevTile.x, prevTile.y, actor.nextDir)) {
                actor.dir = actor.nextDir;
                actor.nextDir = STOP;
            }
            // Check if current direction is blocked
            if (isWall(prevTile.x, prevTile.y, actor.dir)) {
                actor.dir = STOP;
            }
        } else {
            // GHOST AI
            ghostAI(actor);
        }
    }

    // 4. Apply Move (if not stopped)
    if (actor.dir !== STOP) {
        actor.x += actor.dir.x * speed;
        actor.y += actor.dir.y * speed;
    }
}

// --- HELPERS ---
function getTile(x, y) {
    return { x: Math.round(x/TILE), y: Math.round(y/TILE) };
}

function isWall(tx, ty, dir) {
    let nx = tx + dir.x;
    let ny = ty + dir.y;
    // Tunnel
    if (nx < 0 || nx >= COLS) return false;
    if (ny < 0 || ny >= ROWS) return true;
    
    let cell = MAP_DATA[ny][nx];
    return cell === 1 || cell === 4 || cell === 9; 
    // Note: Gate/House (4/9) treated as wall for Pacman standard movement
}

// --- GHOST AI ---
function ghostAI(g) {
    // Define target
    let tx = 0, ty = 0;
    let pTile = getTile(pacman.x, pacman.y);
    
    if (g.state === 'DEAD') { tx = 9; ty = 7; } // House
    else if (g.state === 'EXITING') {
        // Force UP out of house
        if (getTile(g.x, g.y).y <= 5) { g.state = 'CHASE'; g.dir = LEFT; return; }
        g.dir = UP; return;
    } 
    else if (g.state === 'SCARED') { tx = Math.random()*COLS; ty = Math.random()*ROWS; }
    else { tx = pTile.x; ty = pTile.y; } // Chase

    // Available moves (excluding reverse)
    let opts = [UP, DOWN, LEFT, RIGHT].filter(d => {
        // No Reverse
        if (d.x === -g.dir.x && d.y === -g.dir.y && g.state !== 'DEAD') return false;
        
        let t = getTile(g.x, g.y);
        let nx = t.x + d.x, ny = t.y + d.y;
        
        // Bounds
        if (nx < 0 || nx >= COLS) return true; // Tunnel ok
        if (ny < 0 || ny >= ROWS) return false;

        let cell = MAP_DATA[ny][nx];
        // Wall
        if (cell === 1) return false;
        // House Entry (Only Dead/Exiting)
        if ((cell === 4 || cell === 9) && g.state !== 'DEAD' && g.state !== 'EXITING') return false;
        
        return true;
    });

    // Choose move closest to target
    if (opts.length > 0) {
        opts.sort((a,b) => {
            let t = getTile(g.x, g.y);
            let d1 = (t.x+a.x - tx)**2 + (t.y+a.y - ty)**2;
            let d2 = (t.x+b.x - tx)**2 + (t.y+b.y - ty)**2;
            return d1 - d2;
        });
        g.dir = opts[0];
    } else {
        // Dead end? Reverse
        g.dir = {x: -g.dir.x, y: -g.dir.y};
    }
}

// --- MAIN LOOP ---
function gameLoop() {
    if (!gameRunning) return;

    // Draw Map
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // Draw Walls
    ctx.strokeStyle = "#1919A6";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if (MAP_DATA[r][c]===1) ctx.strokeRect(c*TILE+8, r*TILE+8, TILE-16, TILE-16);
            if (MAP_DATA[r][c]===4) { ctx.fillStyle="pink"; ctx.fillRect(c*TILE, r*TILE+14, TILE, 4); }
        }
    }
    ctx.stroke();

    // Power Timer
    if (powerTick > 0) {
        powerTick--;
        if (powerTick === 0) ghosts.forEach(g => { if(g.state==='SCARED') g.state='CHASE'; });
    }

    // Update Actors
    // Pacman Input Reverse Check (Allow immediate 180)
    if (pacman.nextDir.x === -pacman.dir.x && pacman.nextDir.y === -pacman.dir.y) {
        pacman.dir = pacman.nextDir;
        pacman.nextDir = STOP;
    }
    moveActor(pacman, SPEED);
    
    ghosts.forEach(g => {
        let s = (g.state==='DEAD') ? 6 : (g.state==='SCARED' ? 1 : 2); // Integers only
        moveActor(g, s);
        
        // Collision: Simple Box Overlap
        if (Math.abs(g.x - pacman.x) < 16 && Math.abs(g.y - pacman.y) < 16) {
            if (g.state === 'SCARED') {
                g.state = 'DEAD';
                score += 200;
                // Dead ghosts snap to grid
                g.x = Math.round(g.x/TILE)*TILE;
                g.y = Math.round(g.y/TILE)*TILE;
            } else if (g.state === 'CHASE') {
                die();
            }
        }
    });

    // Dots
    let pTile = getTile(pacman.x, pacman.y);
    // Only eat if near center
    if (Math.abs(pacman.x - pTile.x*TILE) < 4 && Math.abs(pacman.y - pTile.y*TILE) < 4) {
        let d = dots.find(d => d.active && d.x === pTile.x && d.y === pTile.y);
        if (d) {
            d.active = false;
            score += d.power ? 50 : 10;
            if (d.power) {
                powerTick = 600;
                ghosts.forEach(g => {
                    if (g.state==='CHASE') {
                        g.state = 'SCARED';
                        g.dir = {x: -g.dir.x, y: -g.dir.y}; // Reverse
                    }
                });
            }
            if (dots.every(d => !d.active)) win();
            updateUI();
        }
    }
    
    // Draw Dots
    dots.forEach(d => {
        if (!d.active) return;
        ctx.fillStyle = "#ffb8ae";
        if (d.power) {
            if (Math.floor(Date.now()/200)%2) {
                ctx.beginPath(); ctx.arc(d.x*TILE+16, d.y*TILE+16, 8, 0, Math.PI*2); ctx.fill();
            }
        } else {
            ctx.fillRect(d.x*TILE+14, d.y*TILE+14, 4, 4);
        }
    });

    // Draw Pacman
    let angle = 0;
    if (pacman.dir === UP) angle = -Math.PI/2;
    if (pacman.dir === DOWN) angle = Math.PI/2;
    if (pacman.dir === LEFT) angle = Math.PI;
    let mouth = (Date.now()%200<100) ? 0.2 : 0.02;
    ctx.fillStyle = "yellow";
    ctx.beginPath();
    ctx.moveTo(pacman.x+16, pacman.y+16);
    ctx.arc(pacman.x+16, pacman.y+16, 13, angle+mouth, angle+2*Math.PI-mouth);
    ctx.fill();

    // Draw Ghosts
    ghosts.forEach(g => {
        let c = g.color;
        if (g.state === 'SCARED') c = (powerTick<120 && Math.floor(Date.now()/100)%2) ? "white" : "blue";
        if (g.state !== 'DEAD') {
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(g.x+16, g.y+14, 14, Math.PI, 0);
            ctx.lineTo(g.x+32, g.y+32);
            ctx.lineTo(g.x, g.y+32);
            ctx.fill();
        }
        // Eyes
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.arc(g.x+10, g.y+12, 4,0,6); ctx.arc(g.x+22, g.y+12, 4,0,6); ctx.fill();
        ctx.fillStyle = "blue";
        ctx.beginPath(); ctx.arc(g.x+10+g.dir.x*2, g.y+12+g.dir.y*2, 2,0,6); ctx.arc(g.x+22+g.dir.x*2, g.y+12+g.dir.y*2, 2,0,6); ctx.fill();
    });

    requestAnimationFrame(gameLoop);
}

function die() {
    lives--;
    updateUI();
    if (lives <= 0) {
        gameRunning = false;
        document.getElementById('msg').innerText = "GAME OVER";
        document.getElementById('overlay').style.display = 'flex';
    } else {
        // Soft Reset
        resetLevel();
    }
}

function win() {
    gameRunning = false;
    document.getElementById('msg').innerText = "YOU WIN";
    document.getElementById('msg').style.color = "gold";
    document.getElementById('overlay').style.display = 'flex';
}

function updateUI() {
    document.getElementById('score').innerText = score;
    document.getElementById('lives').innerText = lives;
}

window.addEventListener('keydown', e => {
    if (["ArrowUp","w"].includes(e.key)) pacman.nextDir = UP;
    if (["ArrowDown","s"].includes(e.key)) pacman.nextDir = DOWN;
    if (["ArrowLeft","a"].includes(e.key)) pacman.nextDir = LEFT;
    if (["ArrowRight","d"].includes(e.key)) pacman.nextDir = RIGHT;
});
	</script>
</body>

</html>